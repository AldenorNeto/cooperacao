<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algoritmo Genético - Sistema de Exploração</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 1200px;
    }

    .canvas-container {
      position: relative;
      margin-bottom: 20px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    canvas {
      background-color: #fff;
      display: block;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button {
      padding: 10px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #45a049;
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      width: 100%;
      margin-bottom: 20px;
    }

    .stat-box {
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .stat-box h3 {
      margin-top: 0;
      color: #555;
      font-size: 14px;
      text-transform: uppercase;
    }

    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
    }

    .info {
      max-width: 800px;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-top: 20px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Algoritmo Genético - Sistema de Exploração</h1>

    <div class="controls">
      <button id="startBtn">Iniciar Simulação</button>
      <button id="pauseBtn" disabled>Pausar</button>
      <button id="resetBtn">Reiniciar</button>
      <button id="nextGenBtn">Próxima Geração</button>
    </div>

    <div class="canvas-container">
      <canvas id="gameCanvas" width="1000" height="600"></canvas>
    </div>

    <div class="stats">
      <div class="stat-box">
        <h3>Geração</h3>
        <div id="generation" class="stat-value">1</div>
      </div>
      <div class="stat-box">
        <h3>Melhor Pontuação</h3>
        <div id="bestScore" class="stat-value">0</div>
      </div>
      <div class="stat-box">
        <h3>Agentes Vivos</h3>
        <div id="aliveAgents" class="stat-value">20</div>
      </div>
      <div class="stat-box">
        <h3>Área Explorada</h3>
        <div id="exploredArea" class="stat-value">0%</div>
      </div>
    </div>
  </div>

  <script>

    const config = {
      populationSize: 50,
      mutationRate: 0.1,
      maxSpeed: 3,
      minSpeed: 0.5,
      turnSpeed: 0.1,
      sensorRange: 80,
      timePerGeneration: 300,
      obstacleCount: 0,
      obstacleRange: 15,
      gridSize: 16,
      explorationBonus: 3.0
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const nextGenBtn = document.getElementById('nextGenBtn');
    const generationEl = document.getElementById('generation');
    const bestScoreEl = document.getElementById('bestScore');
    const aliveAgentsEl = document.getElementById('aliveAgents');
    const exploredAreaEl = document.getElementById('exploredArea');

    let gameState = {
      running: false,
      generation: 1,
      timeLeft: config.timePerGeneration,
      agents: [],
      obstacles: [],
      bestScore: 0,
      centerX: canvas.width / 2,
      centerY: canvas.height / 2,
      explorationGrid: [],
      totalCells: 0,
      exploredCells: 0
    };

    function initExplorationGrid() {
      gameState.explorationGrid = [];
      gameState.totalCells = 0;
      gameState.exploredCells = 0;

      const cols = Math.ceil(canvas.width / config.gridSize);
      const rows = Math.ceil(canvas.height / config.gridSize);

      for (let y = 0; y < rows; y++) {
        const row = [];
        for (let x = 0; x < cols; x++) {
          const cellX = x * config.gridSize;
          const cellY = y * config.gridSize;

          const distX = cellX + config.gridSize / 2 - gameState.centerX;
          const distY = cellY + config.gridSize / 2 - gameState.centerY;
          const distance = Math.sqrt(distX * distX + distY * distY);

          const maxDistance = Math.sqrt(
            Math.pow(gameState.centerX, 2) +
            Math.pow(gameState.centerY, 2)
          );
          const distanceRatio = distance / maxDistance;
          const points = Math.max(1, Math.floor(distanceRatio * 50));

          row.push({
            x: cellX,
            y: cellY,
            explored: false,
            points: points,
            exploredBy: null
          });
          gameState.totalCells++;
        }
        gameState.explorationGrid.push(row);
      }
    }

    class Agent {
      constructor(brain = null) {
        this.x = gameState.centerX;
        this.y = gameState.centerY;
        this.radius = 8;
        this.angle = 0;
        this.speed = 0;
        this.alive = true;
        this.score = 0;
        this.cellsExplored = 0;
        this.sensors = [];
        this.brain = brain || new NeuralNetwork(5, 6, 2);

        for (let i = -2; i <= 2; i++) {
          this.sensors.push({
            angle: i * Math.PI / 8,
            value: 0
          });
        }
      }

      updateSensors() {
        this.sensors.forEach(sensor => {
          const sensorAngle = this.angle + sensor.angle;
          let minDistance = config.sensorRange;

          gameState.obstacles.forEach(obstacle => {
            const distance = this.castRay(this.x, this.y, sensorAngle, obstacle);
            if (distance > 0 && distance < minDistance) {
              minDistance = distance;
            }
          });

          const wallDistance = this.castRayToWall(this.x, this.y, sensorAngle);
          if (wallDistance < minDistance) {
            minDistance = wallDistance;
          }

          sensor.value = minDistance / config.sensorRange;
        });
      }

      castRay(x, y, angle, obstacle) {
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);

        for (let t = 0; t < config.sensorRange; t += 2) {
          const testX = x + dx * t;
          const testY = y + dy * t;

          if (
            testX >= obstacle.x && testX <= obstacle.x + obstacle.width &&
            testY >= obstacle.y && testY <= obstacle.y + obstacle.height
          ) {
            return t;
          }
        }
        return -1;
      }

      castRayToWall(x, y, angle) {
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);

        if (dy !== 0) {
          const tTop = (0 - y) / dy;
          const tBottom = (canvas.height - y) / dy;
          if (tTop > 0 && tTop < config.sensorRange) return tTop;
          if (tBottom > 0 && tBottom < config.sensorRange) return tBottom;
        }

        if (dx !== 0) {
          const tLeft = (0 - x) / dx;
          const tRight = (canvas.width - x) / dx;
          if (tLeft > 0 && tLeft < config.sensorRange) return tLeft;
          if (tRight > 0 && tRight < config.sensorRange) return tRight;
        }

        return config.sensorRange;
      }

      exploreCells() {
        if (!this.alive) return;

        const gridX = Math.floor(this.x / config.gridSize);
        const gridY = Math.floor(this.y / config.gridSize);

        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const checkX = gridX + dx;
            const checkY = gridY + dy;

            if (checkY >= 0 && checkY < gameState.explorationGrid.length &&
              checkX >= 0 && checkX < gameState.explorationGrid[0].length) {

              const cell = gameState.explorationGrid[checkY][checkX];

              if (!cell.explored) {
                cell.explored = true;
                cell.exploredBy = this;
                this.score += cell.points;
                this.cellsExplored++;
                gameState.exploredCells++;
              }
            }
          }
        }
      }

      update() {
        if (!this.alive) return;

        this.updateSensors();
        const inputs = this.sensors.map(sensor => sensor.value);
        const outputs = this.brain.predict(inputs);
        this.angle += (outputs[0] - 0.5) * config.turnSpeed * 2;
        this.speed = config.minSpeed + (outputs[1] * (config.maxSpeed - config.minSpeed));
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.exploreCells();
        this.checkCollisions();
      }

      checkCollisions() {
        for (const obstacle of gameState.obstacles) {
          if (
            this.x + this.radius > obstacle.x &&
            this.x - this.radius < obstacle.x + obstacle.width &&
            this.y + this.radius > obstacle.y &&
            this.y - this.radius < obstacle.y + obstacle.height
          ) {
            this.alive = false;
            return;
          }
        }

        if (
          this.x - this.radius < 0 ||
          this.x + this.radius > canvas.width ||
          this.y - this.radius < 0 ||
          this.y + this.radius > canvas.height
        ) {
          this.alive = false;
        }
      }

      draw() {
        if (!this.alive) return;

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.lineWidth = 1;
        this.sensors.forEach(sensor => {
          const sensorAngle = this.angle + sensor.angle;
          const endX = this.x + Math.cos(sensorAngle) * sensor.value * config.sensorRange;
          const endY = this.y + Math.sin(sensorAngle) * sensor.value * config.sensorRange;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        });

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const speedRatio = (this.speed - config.minSpeed) / (config.maxSpeed - config.minSpeed);
        const red = Math.floor(100 + speedRatio * 155);
        const blue = Math.floor(200 - speedRatio * 100);
        ctx.fillStyle = `rgb(${red}, 100, ${blue})`;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(this.radius, 0);
        ctx.lineTo(-this.radius / 2, -this.radius / 2);
        ctx.lineTo(-this.radius / 2, this.radius / 2);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }

      calculateFitness() {

        return this.score * (this.alive ? config.explorationBonus : 1) + this.cellsExplored;
      }
    }

    class Obstacle {
      constructor(x, y, width, height) {
        this.originalX = x;
        this.originalY = y;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.direction = Math.floor(Math.random() * 4);
        this.phase = Math.random() * Math.PI * 2;
        this.speed = 0.5 + Math.random() * 1;
        this.range = config.obstacleRange;
      }

      update() {
        if (this.range > 0) {
          this.phase += 0.05 * this.speed;
          let dx = 0, dy = 0;
          switch (this.direction) {
            case 0: dy = Math.sin(this.phase) * this.range; break;
            case 1: dy = Math.sin(this.phase) * this.range; break;
            case 2: dx = Math.sin(this.phase) * this.range; break;
            case 3: dx = Math.sin(this.phase) * this.range; break;
          }
          this.x = this.originalX + dx;
          this.y = this.originalY + dy;
        }
      }

      draw() {
        ctx.fillStyle = this.range > 0 ? 'rgba(100, 100, 200, 0.8)' : 'rgba(150, 150, 150, 0.8)';
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    class NeuralNetwork {
      constructor(inputNodes, hiddenNodes, outputNodes) {
        this.inputNodes = inputNodes;
        this.hiddenNodes = hiddenNodes;
        this.outputNodes = outputNodes;
        this.weightsInputHidden = this.randomMatrix(this.inputNodes, this.hiddenNodes);
        this.weightsHiddenOutput = this.randomMatrix(this.hiddenNodes, this.outputNodes);
        this.biasHidden = this.randomArray(this.hiddenNodes);
        this.biasOutput = this.randomArray(this.outputNodes);
      }

      randomMatrix(rows, cols) {
        const matrix = [];
        for (let i = 0; i < rows; i++) {
          matrix[i] = this.randomArray(cols);
        }
        return matrix;
      }

      randomArray(size) {
        const arr = [];
        for (let i = 0; i < size; i++) {
          arr.push(Math.random() * 2 - 1);
        }
        return arr;
      }

      sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
      }

      predict(inputs) {
        const hidden = [];
        for (let i = 0; i < this.hiddenNodes; i++) {
          let sum = 0;
          for (let j = 0; j < this.inputNodes; j++) {
            sum += inputs[j] * this.weightsInputHidden[j][i];
          }
          sum += this.biasHidden[i];
          hidden[i] = this.sigmoid(sum);
        }
        const outputs = [];
        for (let i = 0; i < this.outputNodes; i++) {
          let sum = 0;
          for (let j = 0; j < this.hiddenNodes; j++) {
            sum += hidden[j] * this.weightsHiddenOutput[j][i];
          }
          sum += this.biasOutput[i];
          outputs[i] = this.sigmoid(sum);
        }
        return outputs;
      }

      crossover(partner) {
        const child = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        for (let i = 0; i < this.inputNodes; i++) {
          for (let j = 0; j < this.hiddenNodes; j++) {
            child.weightsInputHidden[i][j] = Math.random() < 0.5 ?
              this.weightsInputHidden[i][j] : partner.weightsInputHidden[i][j];
          }
        }
        for (let i = 0; i < this.hiddenNodes; i++) {
          for (let j = 0; j < this.outputNodes; j++) {
            child.weightsHiddenOutput[i][j] = Math.random() < 0.5 ?
              this.weightsHiddenOutput[i][j] : partner.weightsHiddenOutput[i][j];
          }
        }
        for (let i = 0; i < this.hiddenNodes; i++) {
          child.biasHidden[i] = Math.random() < 0.5 ? this.biasHidden[i] : partner.biasHidden[i];
        }
        for (let i = 0; i < this.outputNodes; i++) {
          child.biasOutput[i] = Math.random() < 0.5 ? this.biasOutput[i] : partner.biasOutput[i];
        }
        return child;
      }

      mutate(rate) {
        for (let i = 0; i < this.inputNodes; i++) {
          for (let j = 0; j < this.hiddenNodes; j++) {
            if (Math.random() < rate) {
              this.weightsInputHidden[i][j] += (Math.random() * 2 - 1) * 0.5;
            }
          }
        }
        for (let i = 0; i < this.hiddenNodes; i++) {
          for (let j = 0; j < this.outputNodes; j++) {
            if (Math.random() < rate) {
              this.weightsHiddenOutput[i][j] += (Math.random() * 2 - 1) * 0.5;
            }
          }
        }
        for (let i = 0; i < this.hiddenNodes; i++) {
          if (Math.random() < rate) {
            this.biasHidden[i] += (Math.random() * 2 - 1) * 0.5;
          }
        }
        for (let i = 0; i < this.outputNodes; i++) {
          if (Math.random() < rate) {
            this.biasOutput[i] += (Math.random() * 2 - 1) * 0.5;
          }
        }
      }

      clone() {
        const clone = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        for (let i = 0; i < this.inputNodes; i++) {
          for (let j = 0; j < this.hiddenNodes; j++) {
            clone.weightsInputHidden[i][j] = this.weightsInputHidden[i][j];
          }
        }
        for (let i = 0; i < this.hiddenNodes; i++) {
          for (let j = 0; j < this.outputNodes; j++) {
            clone.weightsHiddenOutput[i][j] = this.weightsHiddenOutput[i][j];
          }
        }
        for (let i = 0; i < this.hiddenNodes; i++) {
          clone.biasHidden[i] = this.biasHidden[i];
        }
        for (let i = 0; i < this.outputNodes; i++) {
          clone.biasOutput[i] = this.biasOutput[i];
        }
        return clone;
      }
    }

    function init() {
      createObstacles();
      initExplorationGrid();
      createAgents();
      updateStats();
      draw();

      startBtn.addEventListener('click', startSimulation);
      pauseBtn.addEventListener('click', pauseSimulation);
      resetBtn.addEventListener('click', resetSimulation);
      nextGenBtn.addEventListener('click', nextGeneration);
    }

    function createObstacles() {
      gameState.obstacles = [];
      for (let i = 0; i < config.obstacleCount; i++) {
        const width = 15 + Math.random() * 35;
        const height = 15 + Math.random() * 35;
        const x = Math.random() * (canvas.width - width);
        const y = Math.random() * (canvas.height - height);
        const distanceToCenter = Math.sqrt(
          Math.pow(x + width / 2 - gameState.centerX, 2) +
          Math.pow(y + height / 2 - gameState.centerY, 2)
        );
        if (distanceToCenter > 60) {
          gameState.obstacles.push(new Obstacle(x, y, width, height));
        } else {
          i--;
        }
      }
    }

    function createAgents() {
      gameState.agents = [];
      for (let i = 0; i < config.populationSize; i++) {
        gameState.agents.push(new Agent());
      }
    }

    function updateObstacles() {
      gameState.obstacles.forEach(obstacle => {
        obstacle.update();
      });
    }

    function startSimulation() {
      if (gameState.running) return;
      gameState.running = true;
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      gameLoop();
    }

    function pauseSimulation() {
      gameState.running = false;
      startBtn.disabled = false;
      pauseBtn.disabled = true;
    }

    function resetSimulation() {
      gameState.running = false;
      gameState.generation = 1;
      gameState.timeLeft = config.timePerGeneration;
      gameState.bestScore = 0;
      createObstacles();
      initExplorationGrid();
      createAgents();
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      updateStats();
      draw();
    }

    function nextGeneration() {
      gameState.agents.forEach(agent => {
        agent.alive = false;
      });
    }

    function evolvePopulation() {
      const fitnessScores = gameState.agents.map(agent => agent.calculateFitness());
      const bestFitness = Math.max(...fitnessScores);
      gameState.bestScore = Math.max(gameState.bestScore, bestFitness);

      const selectedAgents = [];
      const totalFitness = fitnessScores.reduce((sum, fitness) => sum + fitness, 0);

      for (let i = 0; i < config.populationSize; i++) {
        let randomFitness = Math.random() * totalFitness;
        let accumulatedFitness = 0;
        for (let j = 0; j < gameState.agents.length; j++) {
          accumulatedFitness += fitnessScores[j];
          if (accumulatedFitness >= randomFitness) {
            selectedAgents.push(gameState.agents[j]);
            break;
          }
        }
      }

      const newAgents = [];
      const bestAgentIndex = fitnessScores.indexOf(bestFitness);
      newAgents.push(new Agent(gameState.agents[bestAgentIndex].brain.clone()));

      for (let i = 1; i < config.populationSize; i++) {
        const parentA = selectedAgents[Math.floor(Math.random() * selectedAgents.length)];
        const parentB = selectedAgents[Math.floor(Math.random() * selectedAgents.length)];
        const childBrain = parentA.brain.crossover(parentB.brain);
        childBrain.mutate(config.mutationRate);
        newAgents.push(new Agent(childBrain));
      }

      gameState.agents = newAgents;
      initExplorationGrid();
    }

    function gameLoop() {
      if (!gameState.running) return;
      gameState.timeLeft -= 0.016;

      updateObstacles();

      let aliveCount = 0;
      gameState.agents.forEach(agent => {
        agent.update();
        if (agent.alive) aliveCount++;
      });

      if (gameState.timeLeft <= 0 || aliveCount === 0) {
        gameState.timeLeft = 0;
        gameState.running = false;
        evolvePopulation();
        gameState.generation++;
        gameState.timeLeft = config.timePerGeneration;
        updateStats();
        draw();
        startSimulation();
        return;
      }

      updateStats();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function updateStats() {
      generationEl.textContent = gameState.generation;
      bestScoreEl.textContent = Math.round(gameState.bestScore);
      const aliveCount = gameState.agents.filter(agent => agent.alive).length;
      aliveAgentsEl.textContent = aliveCount;
      const exploredPercent = gameState.totalCells > 0 ?
        Math.round((gameState.exploredCells / gameState.totalCells) * 100) : 0;
      exploredAreaEl.textContent = exploredPercent + '%';
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      gameState.explorationGrid.forEach(row => {
        row.forEach(cell => {
          if (cell.explored) {

            const alpha = 0.3 + (cell.points / 50) * 0.4;
            ctx.fillStyle = `rgba(100, 200, 100, ${alpha})`;
          } else {

            ctx.fillStyle = 'rgba(240, 240, 240, 0.7)';
          }
          ctx.fillRect(cell.x, cell.y, config.gridSize, config.gridSize);

          if (!cell.explored) {
            ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(
              cell.points.toString(),
              cell.x + config.gridSize / 2,
              cell.y + config.gridSize / 2 + 3
            );
          }
        });
      });

      ctx.strokeStyle = 'green';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(gameState.centerX, gameState.centerY, 50, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);

      gameState.obstacles.forEach(obstacle => {
        obstacle.draw();
      });

      gameState.agents.forEach(agent => {
        agent.draw();
      });

      ctx.fillStyle = 'black';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Geração: ${gameState.generation}`, 10, 20);
      ctx.fillText(`Agentes Vivos: ${gameState.agents.filter(a => a.alive).length}`, 10, 40);
      ctx.fillText(`Melhor Pontuação: ${Math.round(gameState.bestScore)}`, 10, 60);
      ctx.fillText(`Tempo: ${Math.round(gameState.timeLeft)}s`, 10, 80);
      ctx.fillText(`Área Explorada: ${Math.round((gameState.exploredCells / gameState.totalCells) * 100)}%`, 10, 100);
    }

    window.onload = init;
  </script>
</body>

</html>