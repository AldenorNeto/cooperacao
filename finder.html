<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Algoritmo Genético Visual — (1 + λ) Agents</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <div class="wrap">
    <div>
      <canvas id="cv"></canvas>
    </div>
    <div class="panel">
      <div class="row">
        <button id="start">Start</button>
        <button id="stop" class="ghost">Stop</button>
        <button id="next" class="ghost">Step Gen</button>
        <button id="reset" class="ghost">Reset</button>
      </div>
      <div class="controls">
        <div class="row"><label>λ (filhos)</label><input id="popSize" type="number" min="1" max="400" value="60"></div>
        <div class="row"><label>σ (mut)</label><input id="sigma" type="range" min="0" max="1" step="0.005" value="0.12"><span class="small" id="sigmaText">0.120</span></div>
        <div class="row"><label>steps por geração</label><input id="stepsPerGen" type="number" min="20" max="5000" value="400"></div>
        <div class="row"><label>velocidade (x)</label><input id="speed" type="range" min="0.1" max="4" step="0.1" value="1"><span class="small" id="speedText">1.0</span></div>
        <div class="checkbox"><input id="showSensors" type="checkbox"><label>Mostrar sensores</label></div>
        <div class="checkbox"><input id="showTrails" type="checkbox" checked><label>Mostrar trilhas</label></div>
        <div class="checkbox"><input id="autoLoop" type="checkbox" checked><label>Loop automático</label></div>
      </div>
      <div class="stats">
        <div>Geração: <span class="value" id="generation">0</span></div>
        <div>Best fitness: <span class="value" id="bestFitness">0.00</span></div>
        <div>Melhor alcançou objetivo: <span class="value" id="bestReached">no</span></div>
        <div class="small">Colisões penalizam; dist menor ao objetivo melhora fitness.</div>
      </div>
      <div>
        <div class="small">Melhor genoma (resumido)</div>
        <div class="genome" id="genomeBox"></div>
      </div>
      <div>
        <div class="small">Histórico de fitness</div>
        <div class="graph" id="graph"></div>
      </div>
      <div class="small">Controles adicionais: clique no canvas para reposicionar objetivo. Obstáculos são gerados aleatoriamente no reset.</div>
    </div>
  </div>
  <script>
    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');
    function fitCanvas(){cv.width = Math.floor(cv.clientWidth);cv.height = Math.floor(cv.clientHeight);}    
    fitCanvas();window.addEventListener('resize', ()=>{fitCanvas();drawScene();});
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const nextBtn = document.getElementById('next');
    const resetBtn = document.getElementById('reset');
    const popSizeInput = document.getElementById('popSize');
    const sigmaRange = document.getElementById('sigma');
    const sigmaText = document.getElementById('sigmaText');
    const stepsPerGenInput = document.getElementById('stepsPerGen');
    const speedRange = document.getElementById('speed');
    const speedText = document.getElementById('speedText');
    const showSensors = document.getElementById('showSensors');
    const showTrails = document.getElementById('showTrails');
    const autoLoop = document.getElementById('autoLoop');
    const generationEl = document.getElementById('generation');
    const bestFitnessEl = document.getElementById('bestFitness');
    const bestReachedEl = document.getElementById('bestReached');
    const genomeBox = document.getElementById('genomeBox');
    const graphEl = document.getElementById('graph');
    sigmaText.textContent = Number(sigmaRange.value).toFixed(3);
    speedText.textContent = Number(speedRange.value).toFixed(1);
    sigmaRange.addEventListener('input', ()=> sigmaText.textContent = Number(sigmaRange.value).toFixed(3));
    speedRange.addEventListener('input', ()=> speedText.textContent = Number(speedRange.value).toFixed(1));

    const rand = (a=0,b=1)=> a + Math.random()*(b-a);
    function gauss(){let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}    
    function clamp(x,a,b){return Math.max(a,Math.min(b,x));}

    const world = {w:0,h:0,goal:{x:0,y:0,r:14},start:{x:40,y:40},obstacles:[]};
    function regenObstacles(){world.obstacles = [];const n = 8 + Math.floor(rand(0,7));for(let i=0;i<n;i++){const ow = Math.floor(rand(40,160));const oh = Math.floor(rand(24,120));const ox = Math.floor(rand(80,cv.width-ow-40));const oy = Math.floor(rand(40,cv.height-oh-40));world.obstacles.push({x:ox,y:oy,w:ow,h:oh});}}

    class Genome{
      constructor(){this.sensorAngles = [-0.7,-0.35,0,0.35,0.7];this.sensorRange = 120;this.weights = new Float32Array(10);for(let i=0;i<10;i++)this.weights[i]=gauss()*0.8;this.biases = new Float32Array(2);this.biases[0]=gauss()*0.1;this.biases[1]=gauss()*0.1}
      clone(){const g = new Genome();g.sensorAngles = this.sensorAngles.slice();g.sensorRange = this.sensorRange;g.weights = new Float32Array(this.weights);g.biases = new Float32Array(this.biases);return g}
      mutate(sigma){for(let i=0;i<this.sensorAngles.length;i++)this.sensorAngles[i]+=gauss()*sigma*0.6;this.sensorRange = Math.max(20,this.sensorRange + gauss()*sigma*80);for(let i=0;i<this.weights.length;i++)this.weights[i]+=gauss()*sigma;for(let i=0;i<this.biases.length;i++)this.biases[i]+=gauss()*sigma}
      serialize(){let s='';s += 'angles:['+this.sensorAngles.map(v=>v.toFixed(2)).join(',')+']\n';s += 'range:'+this.sensorRange.toFixed(0)+'\n';s += 'w:'+Array.from(this.weights).slice(0,10).map(x=>x.toFixed(2)).join(',')+'\n';s += 'b:'+Array.from(this.biases).map(x=>x.toFixed(2)).join(',');return s}
    }

    class Agent{
      constructor(genome){this.g = genome;this.reset();this.fitness=0;this.reached=false;this.collisions=0}
      reset(){this.x = world.start.x + rand(-6,6);this.y = world.start.y + rand(-6,6);this.a = rand(-0.5,0.5);this.v = 0;this.trail = [];this.age=0;this.alive=true;this.fitness=0;this.reached=false;this.collisions=0}
      sense(){const rays = [];const baseAng = this.a;const sr = this.g.sensorRange;for(let i=0;i<this.g.sensorAngles.length;i++){const ang = baseAng + this.g.sensorAngles[i];let dist = sr;const dx = Math.cos(ang);const dy = Math.sin(ang);for(let t=2;t<=sr;t+=4){const px = this.x + dx*t;const py = this.y + dy*t;if(px<0||py<0||px>cv.width||py>cv.height){dist = t;break}let hit=false;for(const ob of world.obstacles){if(px>ob.x && px<ob.x+ob.w && py>ob.y && py<ob.y+ob.h){dist=t;hit=true;break}}if(hit)break}rays.push(dist/sr);}return rays}
      step(dt){if(!this.alive) return;const inputs = this.sense();let acc=0;let rot=0;for(let i=0;i<inputs.length;i++){acc += inputs[i]*this.g.weights[i];rot += inputs[i]*this.g.weights[i+5];}acc += this.g.biases[0];rot += this.g.biases[1];acc = 1/(1+Math.exp(-acc));rot = Math.tanh(rot);const maxSpeed = 2.2;this.v = this.v*0.6 + acc*maxSpeed*0.9;this.a += rot*0.12;this.x += Math.cos(this.a)*this.v*dt;this.y += Math.sin(this.a)*this.v*dt;this.age++;if(showTrails.checked){this.trail.push({x:this.x,y:this.y});if(this.trail.length>160)this.trail.shift()}if(this.x<0||this.y<0||this.x>cv.width||this.y>cv.height){this.alive=false;this.collisions++;return}
        for(const ob of world.obstacles){if(this.x>ob.x && this.x<ob.x+ob.w && this.y>ob.y && this.y<ob.y+ob.h){this.alive=false;this.collisions++;return}}
        const dx = this.x - world.goal.x;const dy = this.y - world.goal.y;const d = Math.hypot(dx,dy);if(d < world.goal.r + 6){this.reached = true;this.alive=false}
      }
      evaluate(maxSteps){const dx = this.x - world.goal.x;const dy = this.y - world.goal.y;const d = Math.hypot(dx,dy);let fit = 0;fit += (1/(1 + d))*200;fit += (this.reached?1000:0);fit += this.age*0.2;fit -= this.collisions*120;return fit}
    }

    let champion = null;let children = [];let population = [];let generation = 0;let animId = null;let running = false;let stepsDone = 0;let targetSteps = Number(stepsPerGenInput.value);

    function init(){world.w = cv.width;world.h = cv.height;world.start = {x:40,y:40};world.goal = {x: cv.width - 80, y: cv.height - 80, r:14};regenObstacles();champion = new Genome();population = [];children = [];population.push(new Agent(champion.clone()));for(let i=0;i<Number(popSizeInput.value);i++)population.push(new Agent(champion.clone()));generation = 0;stepsDone = 0;updateUI();}

    function spawnChildren(){children = [];for(let i=0;i<Number(popSizeInput.value);i++){const g = champion.clone();g.mutate(Number(sigmaRange.value));children.push(new Agent(g));}population = [new Agent(champion.clone()),...children];for(const a of population)a.reset();}

    function stepSimulation(dt){for(const a of population){if(a.alive) a.step(dt);}stepsDone++;}

    function evaluateAndSelect(){let best = population[0];let bestScore = -Infinity;for(const a of population){const s = a.evaluate(stepsDone);if(s>bestScore){bestScore = s;best = a}}if(bestScore > championScore){champion = best.g.clone();championScore = bestScore;bestReached = best.reached}else{bestReached = championReached}generation++;updateHistory(championScore);updateUI();}

    let history = [];let championScore = -Infinity;let championReached = false;let bestReached = false;

    function updateHistory(val){history.push(val);if(history.length>40)history.shift();renderGraph();}

    function renderGraph(){graphEl.innerHTML='';const mx = history.reduce((a,b)=>Math.max(a,b),0) || 1;for(const v of history){const h = Math.max(2, Math.round((v/mx)*54));const bar = document.createElement('div');bar.className='bar';bar.style.height = h+'px';graphEl.appendChild(bar)}}

    function drawScene(){ctx.clearRect(0,0,cv.width,cv.height);ctx.fillStyle='#071226';ctx.fillRect(0,0,cv.width,cv.height);
      for(const ob of world.obstacles){ctx.fillStyle='#1f2937';ctx.fillRect(ob.x,ob.y,ob.w,ob.h);ctx.strokeStyle='rgba(255,255,255,0.03)';ctx.strokeRect(ob.x,ob.y,ob.w,ob.h)}
      ctx.beginPath();ctx.fillStyle='#0ea5a4';ctx.arc(world.goal.x,world.goal.y,world.goal.r,0,Math.PI*2);ctx.fill();
      for(const a of population){if(a.trail && a.trail.length>1 && showTrails.checked){ctx.beginPath();for(let i=0;i<a.trail.length;i++){const p = a.trail[i];if(i===0)ctx.moveTo(p.x,p.y);else ctx.lineTo(p.x,p.y);}ctx.strokeStyle = a===population[0] ? 'rgba(34,197,94,0.9)' : 'rgba(96,165,250,0.08)';ctx.lineWidth = a===population[0] ? 2.2 : 1.0;ctx.stroke()} }
      for(let i=0;i<population.length;i++){const a = population[i];const isChampion = (i===0);ctx.save();ctx.translate(a.x,a.y);ctx.rotate(a.a);
        if(showSensors.checked){const rays = a.sense();for(let j=0;j<rays.length;j++){const ang = a.g.sensorAngles[j];const len = rays[j]*a.g.sensorRange;ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(Math.cos(ang)*len,Math.sin(ang)*len);ctx.strokeStyle = isChampion ? 'rgba(34,197,94,0.6)' : 'rgba(96,165,250,0.06)';ctx.lineWidth = isChampion ? 1.6 : 0.8;ctx.stroke() }}
        ctx.beginPath();ctx.fillStyle = isChampion ? '#16a34a' : 'rgba(99,102,241,0.9)';ctx.arc(0,0,6,0,Math.PI*2);ctx.fill();ctx.restore();}
      ctx.save();ctx.fillStyle='rgba(255,255,255,0.03)';ctx.fillRect(10,10,220,52);ctx.fillStyle='#e2e8f0';ctx.font='12px monospace';ctx.fillText('Champion score: '+championScore.toFixed(2),18,28);ctx.fillText('Generation: '+generation,18,46);ctx.restore();}

    function loop(){if(!running) return;const spd = Number(speedRange.value);for(let i=0;i<spd;i++){if(stepsDone < targetSteps){stepSimulation(1); } else {evaluateAndSelect(); if(autoLoop.checked){spawnChildren();stepsDone=0;targetSteps = Number(stepsPerGenInput.value);} else {running=false;break}}}
      drawScene();animId = requestAnimationFrame(loop);
    }

    cv.addEventListener('click',(e)=>{const r = cv.getBoundingClientRect();world.goal.x = (e.clientX - r.left)*(cv.width/ r.width);world.goal.y = (e.clientY - r.top)*(cv.height/ r.height);drawScene();});

    startBtn.addEventListener('click',()=>{if(!running){running=true;targetSteps = Number(stepsPerGenInput.value);spawnChildren();animId = requestAnimationFrame(loop)}});
    stopBtn.addEventListener('click',()=>{running=false; if(animId) cancelAnimationFrame(animId);animId=null});
    nextBtn.addEventListener('click',()=>{if(running) return;spawnChildren();running=false;targetSteps = Number(stepsPerGenInput.value);for(let i=0;i<targetSteps;i++) stepSimulation(1);evaluateAndSelect();drawScene();});
    resetBtn.addEventListener('click',()=>{running=false; if(animId) cancelAnimationFrame(animId);init();championScore=-Infinity;history=[];renderGraph();drawScene();});

    popSizeInput.addEventListener('change',()=>{});
    stepsPerGenInput.addEventListener('change',()=>{targetSteps = Number(stepsPerGenInput.value)});

    init();spawnChildren();championScore = -Infinity;updateHistory(0);drawScene();

    function updateUI(){generationEl.textContent = generation;bestFitnessEl.textContent = championScore.toFixed(2);bestReachedEl.textContent = bestReached ? 'sim' : 'no';genomeBox.textContent = champion.serialize();}

    function updateHistory(val){history.push(val);if(history.length>40)history.shift();renderGraph();}

    function evaluateAndSelect(){let best=null;let bestScore=-Infinity;for(const a of population){const s = a.evaluate();if(s>bestScore){bestScore=s;best=a}}if(bestScore>championScore){champion = best.g.clone();championScore = bestScore;championReached = best.reached}else{championReached = championReached}generation++;updateUI();updateHistory(championScore)}
  </script>
</body>
</html>
